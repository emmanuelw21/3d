{"ast":null,"code":"import * as THREE from 'three';\nimport { TextureLoader } from 'three';\nimport { useThree, useLoader } from '@react-three/fiber';\nimport * as React from 'react';\nimport { useState } from 'react';\n\n// utils\nconst getFirstItem = param => {\n  if (Array.isArray(param)) {\n    return param[0];\n  } else if (typeof param === 'object' && param !== null) {\n    const keys = Object.keys(param);\n    return param[keys[0]][0];\n  } else {\n    return {\n      w: 0,\n      h: 0\n    };\n  }\n};\nconst checkIfFrameIsEmpty = frameData => {\n  for (let i = 3; i < frameData.length; i += 4) {\n    if (frameData[i] !== 0) {\n      return false;\n    }\n  }\n  return true;\n};\nconst calculateAspectRatio = (width, height, factor, v) => {\n  const adaptedHeight = height * (v.aspect > width / height ? v.width / width : v.height / height);\n  const adaptedWidth = width * (v.aspect > width / height ? v.width / width : v.height / height);\n  const scaleX = adaptedWidth * factor;\n  const scaleY = adaptedHeight * factor;\n  const currentMaxScale = 1;\n  // Calculate the maximum scale based on the aspect ratio and max scale limit\n  let finalMaxScaleW = Math.min(currentMaxScale, scaleX);\n  let finalMaxScaleH = Math.min(currentMaxScale, scaleY);\n\n  // Ensure that scaleX and scaleY do not exceed the max scale while maintaining aspect ratio\n  if (scaleX > currentMaxScale) {\n    finalMaxScaleW = currentMaxScale;\n    finalMaxScaleH = scaleY / scaleX * currentMaxScale;\n  }\n  return new THREE.Vector3(finalMaxScaleW, finalMaxScaleH, 1);\n};\nfunction useSpriteLoader(input, json, animationNames, numberOfFrames, onLoad) {\n  const v = useThree(state => state.viewport);\n  const spriteDataRef = React.useRef(null);\n  const totalFrames = React.useRef(0);\n  const aspectFactor = 0.1;\n  const [spriteData, setSpriteData] = useState(null);\n  const [spriteTexture, setSpriteTexture] = React.useState(new THREE.Texture());\n  const textureLoader = new THREE.TextureLoader();\n  const [spriteObj, setSpriteObj] = useState(null);\n  React.useLayoutEffect(() => {\n    if (json && input) {\n      loadJsonAndTextureAndExecuteCallback(json, input, parseSpriteData);\n    } else if (input) {\n      // only load the texture, this is an image sprite only\n      loadStandaloneSprite();\n    }\n    return () => {\n      if (input) {\n        useLoader.clear(TextureLoader, input);\n      }\n    };\n  }, []);\n  function loadJsonAndTexture(textureUrl, jsonUrl) {\n    if (jsonUrl && textureUrl) {\n      loadJsonAndTextureAndExecuteCallback(jsonUrl, textureUrl, parseSpriteData);\n    } else {\n      loadStandaloneSprite(textureUrl);\n    }\n  }\n  function loadStandaloneSprite(textureUrl) {\n    if (textureUrl || input) {\n      new Promise(resolve => {\n        textureLoader.load(textureUrl !== null && textureUrl !== void 0 ? textureUrl : input, resolve);\n      }).then(texture => {\n        parseSpriteData(null, texture);\n      });\n    }\n  }\n\n  /**\r\n   *\r\n   */\n  function loadJsonAndTextureAndExecuteCallback(jsonUrl, textureUrl, callback) {\n    const jsonPromise = fetch(jsonUrl).then(response => response.json());\n    const texturePromise = new Promise(resolve => {\n      textureLoader.load(textureUrl, resolve);\n    });\n    Promise.all([jsonPromise, texturePromise]).then(response => {\n      callback(response[0], response[1]);\n    });\n  }\n  const parseSpriteData = (json, _spriteTexture) => {\n    let aspect = new THREE.Vector3(1, 1, 1);\n    // sprite only case\n    if (json === null) {\n      if (_spriteTexture && numberOfFrames) {\n        //get size from texture\n        const width = _spriteTexture.image.width;\n        const height = _spriteTexture.image.height;\n        totalFrames.current = numberOfFrames;\n        const {\n          rows,\n          columns,\n          frameWidth,\n          frameHeight,\n          emptyFrames\n        } = getRowsAndColumns(_spriteTexture, numberOfFrames);\n        spriteDataRef.current = {\n          frames: [],\n          meta: {\n            version: '1.0',\n            size: {\n              w: width,\n              h: height\n            },\n            rows,\n            columns,\n            frameWidth,\n            frameHeight,\n            scale: '1'\n          }\n        };\n        for (let row = 0; row < rows; row++) {\n          for (let col = 0; col < columns; col++) {\n            const isExcluded = (emptyFrames !== null && emptyFrames !== void 0 ? emptyFrames : []).some(coord => coord.row === row && coord.col === col);\n            if (isExcluded) {\n              continue;\n            }\n            spriteDataRef.current.frames.push({\n              frame: {\n                x: col * frameWidth,\n                y: row * frameHeight,\n                w: frameWidth,\n                h: frameHeight\n              },\n              rotated: false,\n              trimmed: false,\n              spriteSourceSize: {\n                x: 0,\n                y: 0,\n                w: frameWidth,\n                h: frameHeight\n              },\n              sourceSize: {\n                w: frameWidth,\n                h: frameHeight\n              }\n            });\n          }\n        }\n        aspect = calculateAspectRatio(frameWidth, frameHeight, aspectFactor, v);\n      }\n    } else if (_spriteTexture) {\n      spriteDataRef.current = json;\n      spriteDataRef.current.frames = parseFrames();\n      totalFrames.current = Array.isArray(json.frames) ? json.frames.length : Object.keys(json.frames).length;\n      const {\n        w,\n        h\n      } = getFirstItem(json.frames).sourceSize;\n      aspect = calculateAspectRatio(w, h, aspectFactor, v);\n    }\n    setSpriteData(spriteDataRef.current);\n    // @ts-ignore\n    if ('encoding' in _spriteTexture) _spriteTexture.encoding = 3001; // sRGBEncoding\n    // @ts-ignore\n    else _spriteTexture.colorSpace = 'srgb';\n    setSpriteTexture(_spriteTexture);\n    setSpriteObj({\n      spriteTexture: _spriteTexture,\n      spriteData: spriteDataRef.current,\n      aspect: aspect\n    });\n  };\n  const getRowsAndColumns = (texture, totalFrames) => {\n    if (texture.image) {\n      const canvas = document.createElement('canvas');\n      const ctx = canvas.getContext('2d');\n      canvas.width = texture.image.width;\n      canvas.height = texture.image.height;\n      ctx.drawImage(texture.image, 0, 0);\n      const width = texture.image.width;\n      const height = texture.image.height;\n\n      // Calculate rows and columns based on the number of frames and image dimensions\n      const cols = Math.round(Math.sqrt(totalFrames * (width / height)));\n      const rows = Math.round(totalFrames / cols);\n      const frameWidth = width / cols;\n      const frameHeight = height / rows;\n      const emptyFrames = [];\n      for (let row = 0; row < rows; row++) {\n        for (let col = 0; col < cols; col++) {\n          const frameIndex = row * cols + col;\n          if (frameIndex >= totalFrames) {\n            emptyFrames.push({\n              row,\n              col\n            });\n            continue;\n          }\n          const frameData = ctx.getImageData(col * frameWidth, row * frameHeight, frameWidth, frameHeight).data;\n          const isEmpty = checkIfFrameIsEmpty(frameData);\n          if (isEmpty) {\n            emptyFrames.push({\n              row,\n              col\n            });\n          }\n        }\n      }\n      return {\n        rows,\n        columns: cols,\n        frameWidth,\n        frameHeight,\n        emptyFrames\n      };\n    } else {\n      return {\n        rows: 0,\n        columns: 0,\n        frameWidth: 0,\n        frameHeight: 0,\n        emptyFrames: []\n      };\n    }\n  };\n\n  // for frame based JSON Hash sprite data\n  const parseFrames = () => {\n    const sprites = {};\n    const data = spriteDataRef.current;\n    const delimiters = animationNames;\n    if (delimiters && Array.isArray(data['frames'])) {\n      for (let i = 0; i < delimiters.length; i++) {\n        // we convert each named animation group into an array\n        sprites[delimiters[i]] = [];\n        for (const value of data['frames']) {\n          const frameData = value['frame'];\n          const x = frameData['x'];\n          const y = frameData['y'];\n          const width = frameData['w'];\n          const height = frameData['h'];\n          const sourceWidth = value['sourceSize']['w'];\n          const sourceHeight = value['sourceSize']['h'];\n          if (typeof value['filename'] === 'string' && value['filename'].toLowerCase().indexOf(delimiters[i].toLowerCase()) !== -1) {\n            sprites[delimiters[i]].push({\n              x: x,\n              y: y,\n              w: width,\n              h: height,\n              frame: frameData,\n              sourceSize: {\n                w: sourceWidth,\n                h: sourceHeight\n              }\n            });\n          }\n        }\n      }\n      return sprites;\n    } else if (delimiters && typeof data['frames'] === 'object') {\n      for (let i = 0; i < delimiters.length; i++) {\n        // we convert each named animation group into an array\n        sprites[delimiters[i]] = [];\n        for (const innerKey in data['frames']) {\n          const value = data['frames'][innerKey];\n          const frameData = value['frame'];\n          const x = frameData['x'];\n          const y = frameData['y'];\n          const width = frameData['w'];\n          const height = frameData['h'];\n          const sourceWidth = value['sourceSize']['w'];\n          const sourceHeight = value['sourceSize']['h'];\n          if (typeof innerKey === 'string' && innerKey.toLowerCase().indexOf(delimiters[i].toLowerCase()) !== -1) {\n            sprites[delimiters[i]].push({\n              x: x,\n              y: y,\n              w: width,\n              h: height,\n              frame: frameData,\n              sourceSize: {\n                w: sourceWidth,\n                h: sourceHeight\n              }\n            });\n          }\n        }\n      }\n      return sprites;\n    } else {\n      // we need to convert it into an array\n      const spritesArr = [];\n      for (const key in data.frames) {\n        spritesArr.push(data.frames[key]);\n      }\n      return spritesArr;\n    }\n  };\n  React.useLayoutEffect(() => {\n    onLoad == null || onLoad(spriteTexture, spriteData);\n  }, [spriteTexture, spriteData]);\n  return {\n    spriteObj,\n    loadJsonAndTexture\n  };\n}\nuseSpriteLoader.preload = url => useLoader.preload(TextureLoader, url);\nuseSpriteLoader.clear = input => useLoader.clear(TextureLoader, input);\nexport { calculateAspectRatio, checkIfFrameIsEmpty, getFirstItem, useSpriteLoader };","map":{"version":3,"names":["THREE","TextureLoader","useThree","useLoader","React","useState","getFirstItem","param","Array","isArray","keys","Object","w","h","checkIfFrameIsEmpty","frameData","i","length","calculateAspectRatio","width","height","factor","v","adaptedHeight","aspect","adaptedWidth","scaleX","scaleY","currentMaxScale","finalMaxScaleW","Math","min","finalMaxScaleH","Vector3","useSpriteLoader","input","json","animationNames","numberOfFrames","onLoad","state","viewport","spriteDataRef","useRef","totalFrames","aspectFactor","spriteData","setSpriteData","spriteTexture","setSpriteTexture","Texture","textureLoader","spriteObj","setSpriteObj","useLayoutEffect","loadJsonAndTextureAndExecuteCallback","parseSpriteData","loadStandaloneSprite","clear","loadJsonAndTexture","textureUrl","jsonUrl","Promise","resolve","load","then","texture","callback","jsonPromise","fetch","response","texturePromise","all","_spriteTexture","image","current","rows","columns","frameWidth","frameHeight","emptyFrames","getRowsAndColumns","frames","meta","version","size","scale","row","col","isExcluded","some","coord","push","frame","x","y","rotated","trimmed","spriteSourceSize","sourceSize","parseFrames","encoding","colorSpace","canvas","document","createElement","ctx","getContext","drawImage","cols","round","sqrt","frameIndex","getImageData","data","isEmpty","sprites","delimiters","value","sourceWidth","sourceHeight","toLowerCase","indexOf","innerKey","spritesArr","key","preload","url"],"sources":["J:/PROJECTS - SEAGATE/00 - 3DWEBSITE/3dwebsite02/node_modules/@react-three/drei/core/useSpriteLoader.js"],"sourcesContent":["import * as THREE from 'three';\nimport { TextureLoader } from 'three';\nimport { useThree, useLoader } from '@react-three/fiber';\nimport * as React from 'react';\nimport { useState } from 'react';\n\n// utils\nconst getFirstItem = param => {\n  if (Array.isArray(param)) {\n    return param[0];\n  } else if (typeof param === 'object' && param !== null) {\n    const keys = Object.keys(param);\n    return param[keys[0]][0];\n  } else {\n    return {\n      w: 0,\n      h: 0\n    };\n  }\n};\nconst checkIfFrameIsEmpty = frameData => {\n  for (let i = 3; i < frameData.length; i += 4) {\n    if (frameData[i] !== 0) {\n      return false;\n    }\n  }\n  return true;\n};\nconst calculateAspectRatio = (width, height, factor, v) => {\n  const adaptedHeight = height * (v.aspect > width / height ? v.width / width : v.height / height);\n  const adaptedWidth = width * (v.aspect > width / height ? v.width / width : v.height / height);\n  const scaleX = adaptedWidth * factor;\n  const scaleY = adaptedHeight * factor;\n  const currentMaxScale = 1;\n  // Calculate the maximum scale based on the aspect ratio and max scale limit\n  let finalMaxScaleW = Math.min(currentMaxScale, scaleX);\n  let finalMaxScaleH = Math.min(currentMaxScale, scaleY);\n\n  // Ensure that scaleX and scaleY do not exceed the max scale while maintaining aspect ratio\n  if (scaleX > currentMaxScale) {\n    finalMaxScaleW = currentMaxScale;\n    finalMaxScaleH = scaleY / scaleX * currentMaxScale;\n  }\n  return new THREE.Vector3(finalMaxScaleW, finalMaxScaleH, 1);\n};\nfunction useSpriteLoader(input, json, animationNames, numberOfFrames, onLoad) {\n  const v = useThree(state => state.viewport);\n  const spriteDataRef = React.useRef(null);\n  const totalFrames = React.useRef(0);\n  const aspectFactor = 0.1;\n  const [spriteData, setSpriteData] = useState(null);\n  const [spriteTexture, setSpriteTexture] = React.useState(new THREE.Texture());\n  const textureLoader = new THREE.TextureLoader();\n  const [spriteObj, setSpriteObj] = useState(null);\n  React.useLayoutEffect(() => {\n    if (json && input) {\n      loadJsonAndTextureAndExecuteCallback(json, input, parseSpriteData);\n    } else if (input) {\n      // only load the texture, this is an image sprite only\n      loadStandaloneSprite();\n    }\n    return () => {\n      if (input) {\n        useLoader.clear(TextureLoader, input);\n      }\n    };\n  }, []);\n  function loadJsonAndTexture(textureUrl, jsonUrl) {\n    if (jsonUrl && textureUrl) {\n      loadJsonAndTextureAndExecuteCallback(jsonUrl, textureUrl, parseSpriteData);\n    } else {\n      loadStandaloneSprite(textureUrl);\n    }\n  }\n  function loadStandaloneSprite(textureUrl) {\n    if (textureUrl || input) {\n      new Promise(resolve => {\n        textureLoader.load(textureUrl !== null && textureUrl !== void 0 ? textureUrl : input, resolve);\n      }).then(texture => {\n        parseSpriteData(null, texture);\n      });\n    }\n  }\n\n  /**\r\n   *\r\n   */\n  function loadJsonAndTextureAndExecuteCallback(jsonUrl, textureUrl, callback) {\n    const jsonPromise = fetch(jsonUrl).then(response => response.json());\n    const texturePromise = new Promise(resolve => {\n      textureLoader.load(textureUrl, resolve);\n    });\n    Promise.all([jsonPromise, texturePromise]).then(response => {\n      callback(response[0], response[1]);\n    });\n  }\n  const parseSpriteData = (json, _spriteTexture) => {\n    let aspect = new THREE.Vector3(1, 1, 1);\n    // sprite only case\n    if (json === null) {\n      if (_spriteTexture && numberOfFrames) {\n        //get size from texture\n        const width = _spriteTexture.image.width;\n        const height = _spriteTexture.image.height;\n        totalFrames.current = numberOfFrames;\n        const {\n          rows,\n          columns,\n          frameWidth,\n          frameHeight,\n          emptyFrames\n        } = getRowsAndColumns(_spriteTexture, numberOfFrames);\n        spriteDataRef.current = {\n          frames: [],\n          meta: {\n            version: '1.0',\n            size: {\n              w: width,\n              h: height\n            },\n            rows,\n            columns,\n            frameWidth,\n            frameHeight,\n            scale: '1'\n          }\n        };\n        for (let row = 0; row < rows; row++) {\n          for (let col = 0; col < columns; col++) {\n            const isExcluded = (emptyFrames !== null && emptyFrames !== void 0 ? emptyFrames : []).some(coord => coord.row === row && coord.col === col);\n            if (isExcluded) {\n              continue;\n            }\n            spriteDataRef.current.frames.push({\n              frame: {\n                x: col * frameWidth,\n                y: row * frameHeight,\n                w: frameWidth,\n                h: frameHeight\n              },\n              rotated: false,\n              trimmed: false,\n              spriteSourceSize: {\n                x: 0,\n                y: 0,\n                w: frameWidth,\n                h: frameHeight\n              },\n              sourceSize: {\n                w: frameWidth,\n                h: frameHeight\n              }\n            });\n          }\n        }\n        aspect = calculateAspectRatio(frameWidth, frameHeight, aspectFactor, v);\n      }\n    } else if (_spriteTexture) {\n      spriteDataRef.current = json;\n      spriteDataRef.current.frames = parseFrames();\n      totalFrames.current = Array.isArray(json.frames) ? json.frames.length : Object.keys(json.frames).length;\n      const {\n        w,\n        h\n      } = getFirstItem(json.frames).sourceSize;\n      aspect = calculateAspectRatio(w, h, aspectFactor, v);\n    }\n    setSpriteData(spriteDataRef.current);\n    // @ts-ignore\n    if ('encoding' in _spriteTexture) _spriteTexture.encoding = 3001; // sRGBEncoding\n    // @ts-ignore\n    else _spriteTexture.colorSpace = 'srgb';\n    setSpriteTexture(_spriteTexture);\n    setSpriteObj({\n      spriteTexture: _spriteTexture,\n      spriteData: spriteDataRef.current,\n      aspect: aspect\n    });\n  };\n  const getRowsAndColumns = (texture, totalFrames) => {\n    if (texture.image) {\n      const canvas = document.createElement('canvas');\n      const ctx = canvas.getContext('2d');\n      canvas.width = texture.image.width;\n      canvas.height = texture.image.height;\n      ctx.drawImage(texture.image, 0, 0);\n      const width = texture.image.width;\n      const height = texture.image.height;\n\n      // Calculate rows and columns based on the number of frames and image dimensions\n      const cols = Math.round(Math.sqrt(totalFrames * (width / height)));\n      const rows = Math.round(totalFrames / cols);\n      const frameWidth = width / cols;\n      const frameHeight = height / rows;\n      const emptyFrames = [];\n      for (let row = 0; row < rows; row++) {\n        for (let col = 0; col < cols; col++) {\n          const frameIndex = row * cols + col;\n          if (frameIndex >= totalFrames) {\n            emptyFrames.push({\n              row,\n              col\n            });\n            continue;\n          }\n          const frameData = ctx.getImageData(col * frameWidth, row * frameHeight, frameWidth, frameHeight).data;\n          const isEmpty = checkIfFrameIsEmpty(frameData);\n          if (isEmpty) {\n            emptyFrames.push({\n              row,\n              col\n            });\n          }\n        }\n      }\n      return {\n        rows,\n        columns: cols,\n        frameWidth,\n        frameHeight,\n        emptyFrames\n      };\n    } else {\n      return {\n        rows: 0,\n        columns: 0,\n        frameWidth: 0,\n        frameHeight: 0,\n        emptyFrames: []\n      };\n    }\n  };\n\n  // for frame based JSON Hash sprite data\n  const parseFrames = () => {\n    const sprites = {};\n    const data = spriteDataRef.current;\n    const delimiters = animationNames;\n    if (delimiters && Array.isArray(data['frames'])) {\n      for (let i = 0; i < delimiters.length; i++) {\n        // we convert each named animation group into an array\n        sprites[delimiters[i]] = [];\n        for (const value of data['frames']) {\n          const frameData = value['frame'];\n          const x = frameData['x'];\n          const y = frameData['y'];\n          const width = frameData['w'];\n          const height = frameData['h'];\n          const sourceWidth = value['sourceSize']['w'];\n          const sourceHeight = value['sourceSize']['h'];\n          if (typeof value['filename'] === 'string' && value['filename'].toLowerCase().indexOf(delimiters[i].toLowerCase()) !== -1) {\n            sprites[delimiters[i]].push({\n              x: x,\n              y: y,\n              w: width,\n              h: height,\n              frame: frameData,\n              sourceSize: {\n                w: sourceWidth,\n                h: sourceHeight\n              }\n            });\n          }\n        }\n      }\n      return sprites;\n    } else if (delimiters && typeof data['frames'] === 'object') {\n      for (let i = 0; i < delimiters.length; i++) {\n        // we convert each named animation group into an array\n        sprites[delimiters[i]] = [];\n        for (const innerKey in data['frames']) {\n          const value = data['frames'][innerKey];\n          const frameData = value['frame'];\n          const x = frameData['x'];\n          const y = frameData['y'];\n          const width = frameData['w'];\n          const height = frameData['h'];\n          const sourceWidth = value['sourceSize']['w'];\n          const sourceHeight = value['sourceSize']['h'];\n          if (typeof innerKey === 'string' && innerKey.toLowerCase().indexOf(delimiters[i].toLowerCase()) !== -1) {\n            sprites[delimiters[i]].push({\n              x: x,\n              y: y,\n              w: width,\n              h: height,\n              frame: frameData,\n              sourceSize: {\n                w: sourceWidth,\n                h: sourceHeight\n              }\n            });\n          }\n        }\n      }\n      return sprites;\n    } else {\n      // we need to convert it into an array\n      const spritesArr = [];\n      for (const key in data.frames) {\n        spritesArr.push(data.frames[key]);\n      }\n      return spritesArr;\n    }\n  };\n  React.useLayoutEffect(() => {\n    onLoad == null || onLoad(spriteTexture, spriteData);\n  }, [spriteTexture, spriteData]);\n  return {\n    spriteObj,\n    loadJsonAndTexture\n  };\n}\nuseSpriteLoader.preload = url => useLoader.preload(TextureLoader, url);\nuseSpriteLoader.clear = input => useLoader.clear(TextureLoader, input);\n\nexport { calculateAspectRatio, checkIfFrameIsEmpty, getFirstItem, useSpriteLoader };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}